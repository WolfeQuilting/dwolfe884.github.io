---
title: CCanary
date: 2021-09-24 16:30:00 +/-1111
author: David Wolfe
categories: [Writeups, ALLES CTF]
tags: [ctf,writeup,allesctf] 
---
## Description:
```
I'm using arch btw... ¯\_(ツ)_/¯
```
For this challenge we are given both the compiled C file and the source code for the application.
## Static Analysis
For starters, I ran the application a couple of times to ensure I knew what "normal operation" was for this program.

![Normal](/images/ccanary/normalOps.png)

These first runs of the program show a very simple interface where the user is prompted for input and then that input is echoed out to the screen along with some other themed text. 

After getting this baseline I had a good idea of the types of exploits that this program would be vulnerable to. I knew it was either
```
A.)  A format string vulnerability to leak data for the canary 
B.)  A bufferoverflow to overwrite the canary check.
```
With this in mind I moved on to reviewing the source code that was given to us.

There are a few interesting things we can gather from the source code.

First, we see a C structure for holding our user input. This structure contains not only our user input, but also a canary, and a binary value called `give_flag`. An interesting note while we're looking at this is that the canary is actually a function pointer instead of the typical int value or byte array. This will be interesting to play with when we get to the dynamic analysis portion of the challenge.

![struct](/images/ccanary/struct.png)

Secondly, This program is vulnerable to buffer overflow and and not format string due to the lack of `printf()`. Our struct array holds 32 bytes but the `quotegets()` function does not check the bounds on it's reading. This will be my main mode of exploitation going forward.

![main](/images/ccanary/main.png)

Now that we know what this program is vulnerable to, we can begin the dynamic analysis and exploit development stages.

##  Dynamic Analysis

I began running the program and entered 33 characters to see if it would trigger an overflow.

![1st overflow](/images/ccanary/33chars.png)

And it triggered a seg fault. This is a good since and points to us having control of the programs execution. After further code review I realized that 33 characters was actually overkill for the buffer overflow as the `quotegets()` function appends

My suspicions were confirmed when I saw a call to ```tmpnam_s()``` along with a ```strcat_s()``` call that appended .exe to the end of that tmp name. After seeing this I started looking around in Windows for this new tmp file.

I ended up finding the new file in ```C:\Users\David\AppData\Local\Temp```. It had a random temp name and was another 32 bit executable. While the program was running I copied that file out of temp and pulled it into Ghidra for a closer look.

![2nd Ghidra](/images/packed/ghidra2.PNG)

Here I was finally able to see the prompts for input and the correct and incorrect key responses. At first glance I was also able to find a format string that showed the proper formatting for the license keys ```RA-%d-%s```. I spent some time trying to reverse this code by hand and understand what logical operations were being performed on the name to get to the key. However, there were several variables that didn't get decompiled correctly and I wasn't able to see their initial values. To get around this, I moved on to dynamic analysis.

I found an awesome new tool called [x64dbg](https://x64dbg.com/#start) that looked like it would work perfectly for windows based debugging. I downloaded, installed, and loaded the exe into it. On my first *several* attempts to step through the code it exited immediately. That's when I remembered the debugger checks that were probably killing the execution right at the start. 

![Debug Check](/images/packed/debugCheck.PNG)

After a little bit of searching I was able to find this call to a function that looked like it was checking for debug status. I was able to go into this function call and set a breakpoint right before a specific comparison and change the value of the ```$eax``` register in order to pass this check every time.

With that debug check out of the way. I entered John Smith as the name and started stepping through the program. I ended up seeing the generated key in memory right before the program ended with the incorrect key I had entered.

![Correct Key](/images/packed/answer.PNG)

This showed ```RA-1100-JHRMT``` as the correctly generated key. I threw that into the service running on the game port and sure enough, I got back the flag!

```
ractf{uhhhh I didn't get a screen shot of the flag oops}
```

This challenge was a lot of fun and introduced me to a new tool that is going to be my new goto for exe debugging!

